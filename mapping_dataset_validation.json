{
    "examples": [
        {
            "tla_code": "---- MODULE Lock ---- VARIABLES locked Init == locked = FALSE Lock == locked' = TRUE Unlock == locked' = FALSE Spec == Init /\\ [][Lock \\/ Unlock]_locked ============================================",  
            "java_code": "public class Lock { private boolean locked; public Lock() { this.locked = false; } public void lock() { this.locked = true; } public void unlock() { this.locked = false; } public boolean isLocked() { return locked; } }",
            "positive_examples": [{"tla_element": "locked", "java_element": "boolean locked"}]
            
        },
        {
            "tla_code": "---- MODULE Calculator ---- EXTENDS Naturals VARIABLES lastResult, lastOperation Init == /\\ lastResult = 0 /\\ lastOperation = \"None\" Add(a, b) == /\\ lastResult' = a + b /\\ lastOperation' = \"Addition\" Subtract(a, b) == /\\ lastResult' = a - b /\\ lastOperation' = \"Subtraction\" Multiply(a, b) == /\\ lastResult' = a * b /\\ lastOperation' = \"Multiplication\" Divide(a, b) == /\\ b # 0 /\\ lastResult' = a / b /\\ lastOperation' = \"Division\" Next == \\/ \\E a, b \\in Nat : Add(a, b) \\/ \\E a, b \\in Nat : Subtract(a, b) \\/ \\E a, b \\in Nat : Multiply(a, b) \\/ \\E a, b \\in Nat : Divide(a, b) Spec == Init /\\ [][Next]_<<lastResult, lastOperation>> ============================================",
            "java_code": "public class Calculator { private double lastResult; private String lastOperation; public Calculator() { this.lastResult = 0.0; this.lastOperation = \"None\"; } public double add(double a, double b) { lastResult = a + b; lastOperation = \"Addition\"; return lastResult; } public double subtract(double a, double b) { lastResult = a - b; lastOperation = \"Subtraction\"; return lastResult; } public double multiply(double a, double b) { lastResult = a * b; lastOperation = \"Multiplication\"; return",
            "positive_examples": [{"tla_element": "lastResult", "java_element": "double lastResult"},
                                  {"tla_element": "lastOperation", "java_element": "String lastOperation"}]
            
        },
        {
            "tla_code": "---- MODULE Clock ---- EXTENDS Naturals VARIABLES hour\nInit == hour \\in (0..23) \n hourNext == hour' = IF hour /= 23 THEN hour + 1 ELSE 0 \n Spec == hourInit /\\ [][hourNext]_hour ===============================================================================",
            "java_code": "public class HourClock { private int hour; public HourClock() { this.hour = LocalTime.now().getHour() % 24; } public HourClock(int hour) { if (hour < 0 || hour > 23) { throw new IllegalArgumentException(\"Hour must be between 0 and 23\"); } this.hour = hour; } public int getHour() { return this.hour; } public void nextHour() { if (hour != 23) { hour++; } else { hour = 0; } } public boolean isHourInRange() { return hour >= 0 && hour <= 23; }  }",
            "positive_examples": [{"tla_element": "hour", "java_element": "LocalTime time"},
                                  {"tla_element": "hour \\in (0..23)", "java_element": "this.hour = LocalTime.now().getHour() % 24"},
                                  {"tla_element": "hour \\in (0..23)", "java_element": "this.hour = hour"}]
            
        },
        {
            "tla_code": "---- MODULE DiningPhilosophers ---- EXTENDS Integers, TLC CONSTANTS NP ASSUME /\\ NP \\in Nat \\ {0} VARIABLES forks, pc LeftFork(p) == p RightFork(p) == IF p = NP THEN 1 ELSE p + 1 LeftPhilosopher(p) == IF p = 1 THEN NP ELSE p - 1 RightPhilosopher(p) == IF p = NP THEN 1 ELSE p + 1 IsHoldingBothForks(p) == forks[LeftFork(p)].holder = p /\\ forks[RightFork(p)].holder = p BothForksAreClean(p) == forks[LeftFork(p)].clean /\\ forks[RightFork(p)].clean CanEat(p) == IsHoldingBothForks(p) /\\ BothForksAreClean(p) VARIABLE hungry vars == << forks, pc, hungry >> ProcSet == (1..NP) Init == /\\ forks = [fork \\in 1..NP |-> [holder |-> IF fork = 2 THEN 1 ELSE fork, clean |-> FALSE]] /\\ hungry = [self \\in 1..NP |-> TRUE] /\\ pc = [self \\in ProcSet |-> \"Loop\"] Loop(self) == /\\ pc[self] = \"Loop\" /\\ IF /\\ forks[LeftFork(self)].holder = self /\\ ~forks[LeftFork(self)].clean THEN /\\ forks' = [forks EXCEPT ![LeftFork(self)] = [holder |-> LeftPhilosopher(self), clean |-> TRUE]] ELSE /\\ IF /\\ forks[RightFork(self)].holder = self /\\ ~forks[RightFork(self)].clean THEN /\\ forks' = [forks EXCEPT ![RightFork(self)] = [holder |-> RightPhilosopher(self), clean |-> TRUE]] ELSE /\\ TRUE /\\ forks' = forks /\\ IF hungry[self] THEN /\\ IF CanEat(self) THEN /\\ pc' = [pc EXCEPT ![self] = \"Eat\"] ELSE /\\ pc' = [pc EXCEPT ![self] = \"Loop\"] ELSE /\\ pc' = [pc EXCEPT ![self] = \"Think\"] /\\ UNCHANGED hungry Think(self) == /\\ pc[self] = \"Think\" /\\ hungry' = [hungry EXCEPT ![self] = TRUE] /\\ pc' = [pc EXCEPT ![self] = \"Loop\"] /\\ forks' = forks Eat(self) == /\\ pc[self] = \"Eat\" /\\ hungry' = [hungry EXCEPT ![self] = FALSE] /\\ forks' = [forks EXCEPT ![LeftFork(self)].clean = FALSE, ![RightFork(self)].clean = FALSE] /\\ pc' = [pc EXCEPT ![self] = \"Loop\"] Philosopher(self) == Loop(self) \\/ Think(self) \\/ Eat(self) Next == (\\E self \\in 1..NP: Philosopher(self)) Spec == /\\ Init /\\ [][Next]_vars /\\ \\A self \\in 1..NP : WF_vars(Philosopher(self)) ================================================",
            "java_code": "public class DiningPhilosophers { private static class Fork { private final Lock lock = new ReentrantLock(); private boolean clean = true; private int holder = -1; public boolean isClean() { return clean; } public void setClean(boolean clean) { this.clean = clean; } public int getHolder() { return holder; } public void setHolder(int holder) { this.holder = holder; } public void pickUp(int philosopher) { lock.lock(); holder = philosopher; } public void putDown(int philosopher) { holder = philosopher; clean = false; lock.unlock(); } } private static class Philosopher implements Runnable { private final int id; private final Fork leftFork; private final Fork rightFork; private boolean hungry = true; public Philosopher(int id, Fork leftFork, Fork rightFork) { this.id = id; this.leftFork = leftFork; this.rightFork = rightFork; } public boolean canEat() { return leftFork.getHolder() == id && rightFork.getHolder() == id && leftFork.isClean() && rightFork.isClean(); } @Override public void run() { while (hungry) { think(); synchronized (leftFork) { if (!leftFork.isClean() && leftFork.getHolder() == id) { leftFork.setHolder(id - 1); leftFork.setClean(true); } synchronized (rightFork) { if (!rightFork.isClean() && rightFork.getHolder() == id) { rightFork.setHolder(id + 1); rightFork.setClean(true); } if (canEat()) { eat(); } } } } } private void think() {  try { Thread.sleep(10); } catch (InterruptedException e) { //not implmented } } private void eat() {  leftFork.setClean(false); rightFork.setClean(false); hungry = false; try { Thread.sleep((long) (Math.random() * 1000)); } catch (InterruptedException e) { //not implmented } leftFork.putDown(id); rightFork.putDown(id); } } }",
            "positive_examples": [{"tla_element": "forks"}]
            
        },
        {
            "tla_code": "---------------------------- MODULE Simple ---------------------------- EXTENDS Naturals \n VARIABLES x, y, pc \n vars == << x, y, pc >> ProcSet == (0..N-1) Init == /\\ x = [i \\in 0..(N-1) |-> 0] /\\ y = [i \\in 0..(N-1) |-> 0] /\\ pc = [self \\in ProcSet |-> \"a\"] a(self) == /\\ pc[self] = \"a\" /\\ x' = [x EXCEPT ![self] = 1] /\\ pc' = [pc EXCEPT ![self] = \"b\"] /\\ y' = y b(self) == /\\ pc[self] = \"b\" /\\ y' = [y EXCEPT ![self] = x[(self-1) % N]] /\\ pc' = [pc EXCEPT ![self] = \"Done\"] /\\ x' = x proc(self) == a(self) \\/ b(self) Terminating == /\\ \\A self \\in ProcSet: pc[self] = \"Done\" /\\ UNCHANGED vars Next == (\\E self \\in 0..N-1: proc(self)) \\/ Terminating Spec == Init /\\ [][Next]_vars =============================================================================",
            "java_code": "public class Simple { private int[] valueA; private int[] valueB; private String[] processes; private final int N; private final ReentrantLock lock = new ReentrantLock(); public Simple(int N) { this.N = N; this.valueA = new int[N]; this.valueB = new int[N]; this.processes = new String[N]; Arrays.fill(processes, \"a\"); } private void a(int self) { lock.lock(); try { if (\"a\".equals(processes[self])) { valueA[self] = 1; processes[self] = \"b\"; } } finally { lock.unlock(); } } private void b(int self) { lock.lock(); try { if (\"b\".equals(processes[self])) { valueB[self] = valueA[(self - 1 + N) % N]; processes[self] = \"Done\"; } } finally { lock.unlock(); } } public void proc(int self) { if (\"a\".equals(processes[self])) { a(self); } else if (\"b\".equals(processes[self])) { b(self); } } public boolean isTerminating() { lock.lock(); try { for (String state : processes) { if (!\"Done\".equals(state)) { return false; } } return true; } finally { lock.unlock(); } } public void run() { while (!isTerminating()) { for (int self = 0; self < N; self++) { proc(self); } } } }",
            "positive_examples": [{"tla_element": "VARIABLES x", "java_element": "int[] valueA"},
                                  {"tla_element": "y", "java_element": "int[] valueB"},
                                  {"tla_element": "pc", "java_element": "String[] processes"}
        ]
        },
        {
            "tla_code": "---- MODULE DiningPhilosophers ---- EXTENDS Integers, TLC CONSTANTS NP ASSUME /\\ NP \\in Nat \\ {0} VARIABLES forks, pc LeftFork(p) == p RightFork(p) == IF p = NP THEN 1 ELSE p + 1 LeftPhilosopher(p) == IF p = 1 THEN NP ELSE p - 1 RightPhilosopher(p) == IF p = NP THEN 1 ELSE p + 1 IsHoldingBothForks(p) == forks[LeftFork(p)].holder = p /\\ forks[RightFork(p)].holder = p BothForksAreClean(p) == forks[LeftFork(p)].clean /\\ forks[RightFork(p)].clean CanEat(p) == IsHoldingBothForks(p) /\\ BothForksAreClean(p) VARIABLE hungry vars == << forks, pc, hungry >> ProcSet == (1..NP) Init == /\\ forks = [fork \\in 1..NP |-> [holder |-> IF fork = 2 THEN 1 ELSE fork, clean |-> FALSE]] /\\ hungry = [self \\in 1..NP |-> TRUE] /\\ pc = [self \\in ProcSet |-> \"Loop\"] Loop(self) == /\\ pc[self] = \"Loop\" /\\ IF /\\ forks[LeftFork(self)].holder = self /\\ ~forks[LeftFork(self)].clean THEN /\\ forks' = [forks EXCEPT ![LeftFork(self)] = [holder |-> LeftPhilosopher(self), clean |-> TRUE]] ELSE /\\ IF /\\ forks[RightFork(self)].holder = self /\\ ~forks[RightFork(self)].clean THEN /\\ forks' = [forks EXCEPT ![RightFork(self)] = [holder |-> RightPhilosopher(self), clean |-> TRUE]] ELSE /\\ TRUE /\\ forks' = forks /\\ IF hungry[self] THEN /\\ IF CanEat(self) THEN /\\ pc' = [pc EXCEPT ![self] = \"Eat\"] ELSE /\\ pc' = [pc EXCEPT ![self] = \"Loop\"] ELSE /\\ pc' = [pc EXCEPT ![self] = \"Think\"] /\\ UNCHANGED hungry Think(self) == /\\ pc[self] = \"Think\" /\\ hungry' = [hungry EXCEPT ![self] = TRUE] /\\ pc' = [pc EXCEPT ![self] = \"Loop\"] /\\ forks' = forks Eat(self) == /\\ pc[self] = \"Eat\" /\\ hungry' = [hungry EXCEPT ![self] = FALSE] /\\ forks' = [forks EXCEPT ![LeftFork(self)].clean = FALSE, ![RightFork(self)].clean = FALSE] /\\ pc' = [pc EXCEPT ![self] = \"Loop\"] Philosopher(self) == Loop(self) \\/ Think(self) \\/ Eat(self) Next == (\\E self \\in 1..NP: Philosopher(self)) Spec == /\\ Init /\\ [][Next]_vars /\\ \\A self \\in 1..NP : WF_vars(Philosopher(self)) ================================================",
            "java_code": "public class HourClock { private int hour; public HourClock() { this.hour = LocalTime.now().getHour() % 24; } public HourClock(int hour) { if (hour < 0 || hour > 23) { throw new IllegalArgumentException(\"Hour must be between 0 and 23\"); } this.hour = hour; } public int getHour() { return this.hour; } public void nextHour() { if (hour != 23) { hour++; } else { hour = 0; } } public boolean isHourInRange() { return hour >= 0 && hour <= 23; }  }",
            "positive_examples": [{"tla_element": "forks"}]
            
        },
        {
            "tla_code": "---- MODULE BankingSystem ---- EXTENDS Naturals, Sequences, TLC CONSTANTS CLIENTS VARIABLES accounts, balances Init == /\\ accounts = [c \\in CLIENTS |-> <<>>] /\\ balances = [c \\in CLIENTS |-> 0] Deposit(c, amount) == /\\ c \\in CLIENTS /\\ amount > 0 /\\ balances' = [balances EXCEPT ![c] = @ + amount] /\\ accounts' = [accounts EXCEPT ![c] = @ \\o <<amount>>] Withdraw(c, amount) == /\\ c \\in CLIENTS /\\ amount > 0 /\\ balances[c] >= amount /\\ balances' = [balances EXCEPT ![c] = @ - amount] /\\ accounts' = accounts Next == \\/ \\E c \\in CLIENTS, amount \\in Nat : Deposit(c, amount) \\/ \\E c \\in CLIENTS, amount \\in Nat : Withdraw(c, amount) Spec == Init /\\ [][Next]_<<accounts, balances>> ====",
            "java_code": "public class BankingSystem { private final Map<String, Integer> balances; public BankingSystem(String[] clients) { balances = new HashMap<>(); for (String client : clients) { balances.put(client, 0); } } public synchronized void deposit(String client, int amount) { if (balances.containsKey(client) && amount > 0) { balances.put(client, balances.get(client) + amount);  } else {  } } public synchronized void withdraw(String client, int amount) { if (balances.containsKey(client) && amount > 0 && balances.get(client) >= amount) { balances.put(client, balances.get(client) - amount);  } else {  } } public int getBalance(String client) { return balances.getOrDefault(client, -1); }  }",
            "positive_examples": [{"tla_element": "balances"},{"tla_element": "accounts"}]
            
        }


    ]
}